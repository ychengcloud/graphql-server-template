// Code generated by heidou , DO NOT EDIT.
package services

import (
	"context"
	"fmt"

	"gorm.io/gorm"

	"github.com/99designs/gqlgen/graphql"
	"github.com/99designs/gqlgen/graphql/errcode"
	"github.com/vektah/gqlparser/v2/gqlerror"

	"{{ .Extra.pkgpath }}/internal/generated/models"
)

const (
	edgesField      = "edges"
	nodeField       = "node"
	pageInfoField   = "pageInfo"
	totalCountField = "totalCount"
)

const errInvalidPagination = "INVALID_PAGINATION"

func validateFirstLast(first, last *int) (err *gqlerror.Error) {
	switch {
	case first != nil && last != nil:
		err = &gqlerror.Error{
			Message: "Passing both `first` and `last` to paginate a connection is not supported.",
		}
	case first != nil && *first < 0:
		err = &gqlerror.Error{
			Message: "`first` on a connection cannot be less than zero.",
		}
		errcode.Set(err, errInvalidPagination)
	case last != nil && *last < 0:
		err = &gqlerror.Error{
			Message: "`last` on a connection cannot be less than zero.",
		}
		errcode.Set(err, errInvalidPagination)
	}
	return err
}

func validateOffsetLimit(offset, limit *int) (err *gqlerror.Error) {
	switch {
	case offset != nil && *offset < 0:
		err = &gqlerror.Error{
			Message: "`offset` on a connection cannot be less than zero.",
		}
		errcode.Set(err, errInvalidPagination)
	case limit != nil && *limit < 0:
		err = &gqlerror.Error{
			Message: "`limit` on a connection cannot be less than zero.",
		}
		errcode.Set(err, errInvalidPagination)
	}
	return err
}

func getCollectedField(ctx context.Context, path ...string) *graphql.CollectedField {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return nil
	}
	oc := graphql.GetOperationContext(ctx)
	field := fc.Field

walk:
	for _, name := range path {
		for _, f := range graphql.CollectFields(oc, field.Selections, nil) {
			if f.Name == name {
				field = f
				continue walk
			}
		}
		return nil
	}
	return &field
}

func hasCollectedField(ctx context.Context, path ...string) bool {
	if graphql.GetFieldContext(ctx) == nil {
		return true
	}
	return getCollectedField(ctx, path...) != nil
}

func applyLimit(ctx context.Context, db *gorm.DB, first, last *int) (*gorm.DB, int) {
	var limit int
	if first != nil {
		limit = *first + 1
	} else if last != nil {
		limit = *last + 1
	}
	if limit > 0 {
		db = db.Limit(limit)
	}

	return db, limit
}

func applyCursors(ctx context.Context, db *gorm.DB, direction models.OrderDirection, after, before *models.Cursor, field string) *gorm.DB {
	operator := " < "

	if after != nil {
		if direction == models.OrderDirectionAsc {
			operator = " > "
		}
		if after.Value != nil {
			db = db.Where(fmt.Sprintf("%s%s? ", field, operator), after.Value)
			
			//db = db.Where(fmt.Sprintf("%s%s? AND  %s%s? ", field, operator, idField, operator), after.Value, after.Id)
		}
		// else {
		//	db = db.Where(fmt.Sprintf("%s%s? ", idField, operator), after.Id)
		//}
	}
	if before != nil {
		if direction == models.OrderDirectionDesc {
			operator = " > "
		}
		if before.Value != nil {
			//db = db.Where(fmt.Sprintf("%s%s? AND  %s%s? ", field, operator, idField, operator), before.Value, before.Id)
			db = db.Where(fmt.Sprintf("%s%s? ", field, operator), before.Value)
		} 
		//else {
		//	db = db.Where(fmt.Sprintf("%s%s? ", idField, operator), before.Id)
		//}
	}

	return db
}

// Code generated by hedone, DO NOT EDIT.

package models

import (
	"fmt"
	"io"
	"strconv"
	{{- if .HasTimeField }}
	"time"
	{{- end}}
)

{{- $tableName := .Name}}
{{- $tableNameCamel := .NameCamel}}
type {{.NameCamel}} struct {
	{{- range .Fields}}
	{{- $name := .NameCamel}}
	{{- $type := ""}}
	{{- $associationModel := .JoinTable}}
		{{- if eq .JoinType "None" }}
			{{- if eq $name "DeletedAt" }}
				{{- $type = "gorm.DeletedAt" }}
			{{- else }}
				{{- $type = .MetaType.GoType }}
			{{- end }}
		{{- end }}
		{{- if or (eq .JoinType "BelongTo") (eq .JoinType "HasOne") }}
	{{- $name = .NameCamel}}
	{{- $type = (printf "%s%s" "*" $associationModel.NameCamel)}}
		{{- end}}
		{{- if or (eq .JoinType "ManyToMany") (eq .JoinType "HasMany") }}
	{{- $name = .NameCamelPlural}}
	{{- $type = (printf "%s%s" "[]*" $associationModel.NameCamel)}}
		{{- end}}
	{{$name}} {{$type}} `{{.TagsHTML}}`
	{{- end}}
}

//TableName
func (m *{{.NameCamel}}) TableName() string {
	return "{{.Name}}"
}

func ({{.NameCamel}}) IsNode()   {}
func ({{.NameCamel}}) IsEntity() {}

type {{.NameCamel}}Connection struct {
	PageInfo   PageInfo       `json:"pageInfo"`
	Edges      []*{{.NameCamel}}Edge `json:"edges"`
	TotalCount int             `json:"totalCount"`
}

type {{.NameCamel}}Create struct {
	Errors  []*{{.NameCamel}}Error `json:"errors"`
	{{.NameCamel}} *{{.NameCamel}}              `json:"{{.NameLowerCamel}}"`
}

type {{.NameCamel}}Update struct {
	Errors  []*{{.NameCamel}}Error `json:"errors"`
	Count  int              `json:"count"`
}

type {{.NameCamel}}Delete struct {
	Errors  []*{{.NameCamel}}Error `json:"errors"`
	Count  int              `json:"count"`
}

type {{.NameCamel}}Edge struct {
	Node   *{{.NameCamel}} `json:"node"`
	Cursor Cursor   `json:"cursor"`
}

type {{.NameCamel}}Error struct {
	Field   string           `json:"field"`
	Message string           `json:"message"`
	Code    {{.NameCamel}}ErrorCode `json:"code"`
}

type {{.NameCamel}}Input struct {
	{{- range .Fields}}
		{{- if not .IsPrimaryKey}}
			{{- if not (eq .NameCamel "DeletedAt") }}
				{{- if not (eq .NameCamel "UpdatedAt") }}
					{{- if not (eq .NameCamel "CreatedAt") }}
						{{- if not (eq .NameCamel "CreateBy") }}
							{{- if not (eq .NameCamel "UpdateBy") }}
							{{- $name := .NameCamel}}
							{{- $type := ""}}
							{{- $associationModel := .JoinTable}}
								{{- if eq .JoinType "None" }}
							{{- $type = .MetaType.GoType }}
								{{- end }}
								{{- if or (eq .JoinType "BelongTo") (eq .JoinType "HasOne") }}
							{{- $name = .NameCamel}}
							{{- $type = (printf "*%sInput" $associationModel.NameCamel)}}
								{{- end}}
								{{- if or (eq .JoinType "ManyToMany") (eq .JoinType "HasMany") }}
							{{- $name = .NameCamelPlural}}
							{{- $type = (printf "%s%sInput" "[]*" $associationModel.NameCamel)}}
								{{- end}}
							{{$name}} {{$type}} `{{.TagsHTML}}`
							{{- end}}
						{{- end}}
					{{- end}}
				{{- end}}
			{{- end}}
		{{- end}}
	{{- end}}
}

type {{.NameCamel}}FilterInput struct {
	{{- range .Fields}}
	{{- if .IsFilterable}}
	{{.NameCamel}} *{{$tableNameCamel}}Op{{.NameCamel}}Input
	{{- end}}
	{{- end}}
	AND []*{{$tableNameCamel}}FilterInput
  	OR []*{{$tableNameCamel}}FilterInput
}
{{- range .Fields}}
{{- if .IsFilterable}}
type {{$tableNameCamel}}Op{{.NameCamel}}Input struct {
  {{- $t := (printf "*%s" .MetaType.GoType)}}
  {{- range .Operations}}
  {{- if eq . "In"}}
  {{- $t = (printf "[]%s" $t)}}
  {{- end}}
  {{.}} {{$t}}
  {{- end}}
}
{{- end}}
{{- end}}

func (i *{{.NameCamel}}Input) ToORM() *{{.NameCamel}} {
	{{.NameLowerCamel}} := &{{.NameCamel}}{
		{{- range .Fields}}
			{{- if eq .JoinType "None"}}
				{{- if not .IsPrimaryKey}}
					{{- if not (eq .NameCamel "DeletedAt") }}
						{{- if not (eq .NameCamel "UpdatedAt") }}
							{{- if not (eq .NameCamel "CreatedAt") }}
								{{- if not (eq .NameCamel "CreateBy") }}
									{{- if not (eq .NameCamel "UpdateBy") }}
										{{.NameCamel}}: i.{{.NameCamel}},
									{{- end}}
								{{- end}}
							{{- end}}
						{{- end}}
					{{- end}}
				{{- end}}
			{{- end}}
		{{- end}}
	}

	{{- $nameLowerCamelInput := .NameLowerCamel}}
	{{- range .Fields}}
	{{- if or (eq .JoinType "HasMany") (eq .JoinType "ManyToMany") }}
	if i.{{.NameCamelPlural}} != nil {
		{{- $associationModel := .JoinTable}}

		{{.NameLowerCamelPlural}} := make([]*{{$associationModel.NameCamel}}, 0, len(i.{{.NameCamelPlural}}))
		for _, {{.NameLowerCamel}} := range i.{{.NameCamelPlural}} {
			{{.NameLowerCamelPlural}} = append({{.NameLowerCamelPlural}}, {{.NameLowerCamel}}.ToORM())
		}
		{{$nameLowerCamelInput}}.{{.NameCamelPlural}} = {{.NameLowerCamelPlural}}
	}
	{{- end}}
	{{- if or (eq .JoinType "HasOne") (eq .JoinType "BelongTo") }}
	if i.{{.NameCamel}} != nil {
		{{$nameLowerCamelInput}}.{{.NameCamel}} = i.{{.NameCamel}}.ToORM()
	}
	{{- end}}
	{{- end}}
	
	return {{.NameLowerCamel}}
}

type {{.NameCamel}}Order struct {
	Direction OrderDirection   `json:"direction"`
	Field     *{{.NameCamel}}OrderField `json:"field"`
}

type {{.NameCamel}}OrderField struct {
	Field    string
	ToCursor func(*{{$tableNameCamel}}) Cursor
}

{{- $primaryKeyField := .PrimaryKeyField}}
var (
	{{$tableNameCamel}}OrderField{{ $primaryKeyField.NameCamel }} = &{{$tableNameCamel}}OrderField{
		Field: "{{$primaryKeyField.NameCamel}}",
		ToCursor: func(p *{{$tableNameCamel}}) Cursor {
			return Cursor{
				//Id:    p.{{ $primaryKeyField.NameCamel }},
				Value: p.{{ $primaryKeyField.NameCamel }},
			}
		},
	}
	{{- range .Fields}}
	{{- if .IsSortable}}
	{{$tableNameCamel}}OrderField{{.NameCamel}} = &{{$tableNameCamel}}OrderField{
		Field: "{{.NameCamel}}",
		ToCursor: func(p *{{$tableNameCamel}}) Cursor {
			return Cursor{
				//Id:    p.{{ $primaryKeyField.NameCamel }},
				Value: p.{{.NameCamel}},
			}
		},
	}
	{{- end}}
	{{- end}}
)

var All{{.NameCamel}}OrderField = []*{{.NameCamel}}OrderField{
	{{$tableNameCamel}}OrderField{{ .PrimaryKeyField.NameCamel }},
	{{- range .Fields}}
	{{- if .IsSortable}}
	{{$tableNameCamel}}OrderField{{.NameCamel}},
	{{- end}}
	{{- end}}
}

func (f {{.NameCamel}}OrderField) String() string {
	var str string
	switch f.Field {
	case "{{ .PrimaryKeyField.NameCamel }}":
		str = "{{ .PrimaryKeyField.NameSnake | ToUpper }}"
	{{- range .Fields}}
	{{- if .IsSortable}}
	case "{{.NameCamel}}":
		str = "{{.NameSnake | ToUpper}}"
	{{- end}}
	{{- end}}
	}
	return str
}

func (f *{{.NameCamel}}OrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	switch str {
	case "{{ .PrimaryKeyField.NameSnake | ToUpper }}":
		*f = *{{.NameCamel}}OrderField{{ .PrimaryKeyField.NameCamel }}
	{{- range .Fields}}
	{{- if .IsSortable}}
	case "{{.NameSnake | ToUpper}}":
		*f = *{{$tableNameCamel}}OrderField{{.NameCamel}}
	{{- end}}
	{{- end}}
	default:
		return fmt.Errorf("%s is not a valid {{.NameCamel}}OrderField", str)
	}
	return nil
}

func (f {{.NameCamel}}OrderField) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(f.String()))
}

type {{.NameCamel}}ErrorCode string

const (
	{{$tableNameCamel}}ErrorCodeInvalid	{{$tableNameCamel}}ErrorCode = "Invalid"

	{{$tableNameCamel}}ErrorCodeNotFound	{{$tableNameCamel}}ErrorCode = "NotFound"
	
	{{$tableNameCamel}}ErrorCodeAlreadyExists	{{$tableNameCamel}}ErrorCode = "AlreadyExists"
	
	{{range .ErrorCodes}}
	{{$tableNameCamel}}ErrorCode{{.}}	{{$tableNameCamel}}ErrorCode = "{{.}}"
	{{end}}
)

var All{{.NameCamel}}ErrorCode = []{{.NameCamel}}ErrorCode{
	{{$tableNameCamel}}ErrorCodeInvalid,
	{{$tableNameCamel}}ErrorCodeNotFound,
	{{$tableNameCamel}}ErrorCodeAlreadyExists,
	{{- range .ErrorCodes}}
	{{$tableNameCamel}}ErrorCode{{.}},
	{{- end}}
}

func (e {{.NameCamel}}ErrorCode) IsValid() bool {
	switch e {
	case {{$tableNameCamel}}ErrorCodeInvalid, {{$tableNameCamel}}ErrorCodeNotFound, {{$tableNameCamel}}ErrorCodeAlreadyExists:
		return true
	{{range .ErrorCodes}}
	case {{$tableNameCamel}}ErrorCode{{.}}:
		return true
 	{{end}}
	}
	return false
}

func (e {{.NameCamel}}ErrorCode) String() string {
	return string(e)
}

func (e *{{.NameCamel}}ErrorCode) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = {{.NameCamel}}ErrorCode(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid {{.NameCamel}}ErrorCode", str)
	}
	return nil
}

func (e {{.NameCamel}}ErrorCode) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Default{{.NameCamel}}Order is the default ordering of {{.NameCamel}}.
var Default{{.NameCamel}}Order = &{{.NameCamel}}Order{
	Direction: OrderDirectionAsc,
	Field: &{{.NameCamel}}OrderField{
		Field: "Id",
		ToCursor: func(p *{{.NameCamel}}) Cursor {
			return Cursor{Value: p.Id}
		},
	},
}
